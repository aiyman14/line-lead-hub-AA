name: Desktop Build

on:
  workflow_dispatch:
  push:
    tags:
      - "desktop-v*"

permissions:
  contents: write

jobs:
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-22.04
            platform: linux-x86_64
          - os: windows-latest
            platform: windows-x86_64
          - os: macos-latest
            platform: darwin-universal

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Ensure the built desktop binaries' version matches the release tag.
      - name: Sync app version from tag
        if: startsWith(github.ref, 'refs/tags/desktop-v')
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${GITHUB_REF_NAME#desktop-v}"
          export VERSION
          echo "Building desktop version: $VERSION"

          python - <<'PY'
          import json
          import os
          import re
          from pathlib import Path

          version = os.environ.get('VERSION')
          if not version:
            raise SystemExit('VERSION env var not set')

          # Update src-tauri/tauri.conf.json
          conf_path = Path('src-tauri/tauri.conf.json')
          conf = json.loads(conf_path.read_text(encoding='utf-8'))
          conf['version'] = version
          conf_path.write_text(json.dumps(conf, indent=2) + "\n", encoding='utf-8')

          # Update src-tauri/Cargo.toml (package.version)
          cargo_path = Path('src-tauri/Cargo.toml')
          cargo_text = cargo_path.read_text(encoding='utf-8')
          cargo_text = re.sub(r'(?m)^version\s*=\s*"[^"]+"\s*$', f'version = "{version}"', cargo_text, count=1)
          cargo_path.write_text(cargo_text, encoding='utf-8')
          PY

      - name: Install Linux dependencies
        if: matrix.os == 'ubuntu-22.04'
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            pkg-config \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            librsvg2-dev \
            libsoup-3.0-dev \
            patchelf

          sudo apt-get install -y libayatana-appindicator3-dev || sudo apt-get install -y libappindicator3-dev

          echo "PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/share/pkgconfig" >> $GITHUB_ENV
          pkg-config --modversion libsoup-3.0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Add macOS universal target
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          rustup target add x86_64-apple-darwin
          rustup target add aarch64-apple-darwin

      - name: Install frontend deps
        run: npm ci

      # Write the Tauri updater signing key (stored in GitHub Secrets) to a file
      - name: Write Tauri signing key to file
        shell: bash
        run: |
          mkdir -p ~/.tauri
          printf '%s' "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" > ~/.tauri/production-portal.key
          chmod 600 ~/.tauri/production-portal.key

      # ---------- BUILD ----------
      - name: Build desktop app (Tauri) - Linux/Windows
        if: matrix.os != 'macos-latest'
        run: npm run tauri:build
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Build desktop app (Tauri) - macOS Universal
        if: matrix.os == 'macos-latest'
        run: npm run tauri:build -- --target universal-apple-darwin
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      # ---------- NOTARIZE (DMG) ----------
      - name: Notarize + staple macOS DMG
        if: matrix.os == 'macos-latest'
        shell: bash
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail

          DMG=$(find "src-tauri/target/universal-apple-darwin/release/bundle/dmg" -name "*.dmg" -type f 2>/dev/null | head -1)
          if [ -z "${DMG:-}" ]; then
            DMG=$(find "src-tauri/target/release/bundle/dmg" -name "*.dmg" -type f 2>/dev/null | head -1)
          fi

          if [ -z "${DMG:-}" ] || [ ! -f "$DMG" ]; then
            echo "Could not find DMG to notarize" >&2
            exit 1
          fi

          retry() {
            local n=0
            local max=6
            local delay=20
            until "$@"; do
              n=$((n+1))
              if [ "$n" -ge "$max" ]; then
                echo "Command failed after $n attempts: $*" >&2
                return 1
              fi
              echo "Command failed (attempt $n/$max). Retrying in ${delay}s..." >&2
              sleep "$delay"
              delay=$((delay*2))
            done
          }

          echo "Submitting for notarization: $DMG"

          SUBMIT_JSON="$(retry xcrun notarytool submit "$DMG" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --output-format json)"

          echo "Submit output:"
          echo "$SUBMIT_JSON"

          UUID="$(python3 - <<'PY'
import json, sys
data = json.loads(sys.stdin.read())
print(data.get("id",""))
PY
<<< "$SUBMIT_JSON")"

          if [ -z "${UUID:-}" ]; then
            echo "Failed to extract notarization submission UUID." >&2
            exit 1
          fi

          echo "Notary submission id: $UUID"

          # ---- Wait until status is Accepted/Invalid ----
          MAX_WAIT_SECONDS=7200   # 2 hours max
          SLEEP_SECONDS=45
          elapsed=0

          while [ "$elapsed" -lt "$MAX_WAIT_SECONDS" ]; do
            INFO_JSON="$(retry xcrun notarytool info "$UUID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --output-format json || true)"

            STATUS="$(python3 - <<'PY'
import json, sys
try:
  data = json.loads(sys.stdin.read())
  print((data.get("status") or "").strip())
except Exception:
  print("")
PY
<<< "${INFO_JSON:-}")"

            echo "Notary status: ${STATUS:-unknown}"

            if [ "$STATUS" = "Accepted" ]; then
              break
            fi

            if [ "$STATUS" = "Invalid" ] || [ "$STATUS" = "Rejected" ]; then
              echo "Notarization failed. Fetching log..." >&2
              xcrun notarytool log "$UUID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
              exit 1
            fi

            sleep "$SLEEP_SECONDS"
            elapsed=$((elapsed+SLEEP_SECONDS))
          done

          if [ "$elapsed" -ge "$MAX_WAIT_SECONDS" ]; then
            echo "Notarization still not finished after ${MAX_WAIT_SECONDS}s. Fetching log and failing." >&2
            xcrun notarytool log "$UUID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" || true
            exit 1
          fi

          echo "Notarization Accepted. Waiting for ticket propagation..."
          sleep 120

          echo "Stapling notarization ticket..."
          retry xcrun stapler staple "$DMG"

          echo "Stapler validate..."
          xcrun stapler validate "$DMG" || true

          echo "Gatekeeper verification:"
          spctl -a -vv "$DMG" || true

      # ---------- COLLECT ARTIFACTS ----------
      - name: Collect artifact info (Linux)
        if: matrix.os == 'ubuntu-22.04'
        shell: bash
        run: |
          mkdir -p artifacts
          APPIMAGE=$(find src-tauri/target/release/bundle -name "*.AppImage" -type f | head -1)
          if [ -n "${APPIMAGE:-}" ] && [ -f "$APPIMAGE" ]; then
            cp "$APPIMAGE" artifacts/
            if [ -f "$APPIMAGE.sig" ]; then
              cat "$APPIMAGE.sig" > artifacts/linux-x86_64.sig
            fi
          fi
          find src-tauri/target/release/bundle -name "*.deb" -exec cp {} artifacts/ \; || true
          find src-tauri/target/release/bundle -name "*.rpm" -exec cp {} artifacts/ \; || true

      - name: Collect artifact info (Windows)
        if: matrix.os == 'windows-latest'
        shell: bash
        run: |
          mkdir -p artifacts
          MSI=$(find src-tauri/target/release/bundle -name "*.msi" -type f | head -1)
          if [ -n "${MSI:-}" ] && [ -f "$MSI" ]; then
            cp "$MSI" artifacts/
            if [ -f "$MSI.sig" ]; then
              cat "$MSI.sig" > artifacts/windows-x86_64.sig
            fi
          fi
          find src-tauri/target/release/bundle -name "*.exe" -exec cp {} artifacts/ \; || true

      - name: Collect artifact info (macOS)
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          mkdir -p artifacts

          MACOS_UPDATE=$(find src-tauri/target/universal-apple-darwin/release/bundle/macos -name "*.app.tar.gz" -type f 2>/dev/null | head -1)
          if [ -z "${MACOS_UPDATE:-}" ]; then
            MACOS_UPDATE=$(find src-tauri/target/release/bundle/macos -name "*.app.tar.gz" -type f 2>/dev/null | head -1)
          fi

          if [ -n "${MACOS_UPDATE:-}" ] && [ -f "$MACOS_UPDATE" ]; then
            cp "$MACOS_UPDATE" artifacts/
            if [ -f "$MACOS_UPDATE.sig" ]; then
              cat "$MACOS_UPDATE.sig" > artifacts/darwin-aarch64.sig
              cat "$MACOS_UPDATE.sig" > artifacts/darwin-x86_64.sig
            fi
          fi

          DMG=$(find src-tauri/target/universal-apple-darwin/release/bundle -name "*.dmg" -type f 2>/dev/null | head -1)
          if [ -z "${DMG:-}" ]; then
            DMG=$(find src-tauri/target/release/bundle -name "*.dmg" -type f 2>/dev/null | head -1)
          fi
          if [ -n "${DMG:-}" ] && [ -f "$DMG" ]; then
            cp "$DMG" artifacts/
          fi

      - name: Upload installers
        uses: actions/upload-artifact@v4
        with:
          name: installers-${{ matrix.platform }}
          if-no-files-found: error
          path: artifacts/

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/desktop-v')

    steps:
      - name: Download all installers
        uses: actions/download-artifact@v4
        with:
          pattern: installers-*
          path: dist
          merge-multiple: true

      - name: List downloaded artifacts
        run: |
          echo "Downloaded artifacts:"
          find dist -type f -ls

      - name: Create Release + Upload Assets
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          name: Production Portal ${{ github.ref_name }}
          body: |
            ## Desktop installers for Production Portal

            | Platform | Download |
            |----------|----------|
            | macOS (Universal) | `.dmg` file below |
            | Windows | `.msi` file below |
            | Linux | `.AppImage`, `.deb`, or `.rpm` files below |

            The app will automatically check for updates.
          allowUpdates: true
          replacesArtifacts: true
          artifacts: |
            dist/*.AppImage
            dist/*.deb
            dist/*.rpm
            dist/*.dmg
            dist/*.app.tar.gz
            dist/*.msi
            dist/*.exe
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate latest.json (use actual uploaded asset URLs)
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          TAG="${{ github.ref_name }}"
          VERSION="${TAG#desktop-v}"
          REPO="WovenTexLTD/line-lead-hub"
          PUB_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          curl -sSL \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/releases/tags/$TAG" \
            > dist/release.json

          python3 - <<'PY' > dist/asset_urls.env
          import json
          with open('dist/release.json', 'r', encoding='utf-8') as f:
            data = json.load(f)
          assets = data.get('assets', []) or []
          def find_url(endswith: str) -> str:
            for a in assets:
              name = a.get('name', '') or ''
              if name.endswith(endswith):
                return a.get('browser_download_url', '') or ''
            return ''
          linux_url = find_url('.AppImage')
          windows_url = find_url('.msi')
          macos_url = find_url('.app.tar.gz')
          print(f"LINUX_URL={linux_url}")
          print(f"WINDOWS_URL={windows_url}")
          print(f"MACOS_URL={macos_url}")
          PY

          source dist/asset_urls.env

          if [ -z "${LINUX_URL:-}" ]; then
            echo "Could not find Linux .AppImage asset URL in release" >&2
            exit 1
          fi
          if [ -z "${WINDOWS_URL:-}" ]; then
            echo "Could not find Windows .msi asset URL in release" >&2
            exit 1
          fi
          if [ -z "${MACOS_URL:-}" ]; then
            echo "Could not find macOS .app.tar.gz asset URL in release" >&2
            exit 1
          fi

          if [ ! -f "dist/linux-x86_64.sig" ] || [ ! -f "dist/windows-x86_64.sig" ]; then
            echo "Missing linux-x86_64.sig or windows-x86_64.sig in dist" >&2
            exit 1
          fi

          LINUX_SIG=$(tr -d '\n' < dist/linux-x86_64.sig)
          WINDOWS_SIG=$(tr -d '\n' < dist/windows-x86_64.sig)

          DARWIN_SIG=""
          if [ -f "dist/darwin-aarch64.sig" ]; then
            DARWIN_SIG=$(tr -d '\n' < dist/darwin-aarch64.sig)
          elif [ -f "dist/darwin-x86_64.sig" ]; then
            DARWIN_SIG=$(tr -d '\n' < dist/darwin-x86_64.sig)
          fi

          if [ -z "$DARWIN_SIG" ]; then
            echo "Missing macOS signature (darwin-aarch64.sig or darwin-x86_64.sig) in dist" >&2
            exit 1
          fi

          cat > dist/latest.json << EOF
          {
            "version": "$VERSION",
            "notes": "Production Portal update",
            "pub_date": "$PUB_DATE",
            "platforms": {
              "linux-x86_64": { "url": "$LINUX_URL", "signature": "$LINUX_SIG" },
              "windows-x86_64": { "url": "$WINDOWS_URL", "signature": "$WINDOWS_SIG" },
              "darwin-aarch64": { "url": "$MACOS_URL", "signature": "$DARWIN_SIG" },
              "darwin-x86_64": { "url": "$MACOS_URL", "signature": "$DARWIN_SIG" }
            }
          }
          EOF

          echo "Generated latest.json:"
          cat dist/latest.json

      - name: Upload latest.json
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          allowUpdates: true
          replacesArtifacts: true
          artifacts: dist/latest.json
          token: ${{ secrets.GITHUB_TOKEN }}
