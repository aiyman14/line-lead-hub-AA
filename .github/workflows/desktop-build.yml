name: Desktop Build

on:
  workflow_dispatch:
  push:
    tags:
      - "desktop-v*"

permissions:
  contents: write

jobs:
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-22.04
            platform: linux-x86_64
          - os: windows-latest
            platform: windows-x86_64
          - os: macos-latest
            platform: darwin-universal

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Ensure the built desktop binaries' version matches the release tag.
      - name: Sync app version from tag
        if: startsWith(github.ref, 'refs/tags/desktop-v')
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${GITHUB_REF_NAME#desktop-v}"
          export VERSION
          echo "Building desktop version: $VERSION"

          python - <<'PY'
          import json
          import os
          import re
          from pathlib import Path

          version = os.environ.get('VERSION')
          if not version:
            raise SystemExit('VERSION env var not set')

          conf_path = Path('src-tauri/tauri.conf.json')
          conf = json.loads(conf_path.read_text(encoding='utf-8'))

          # Update version in the most common locations (works across config shapes)
          if isinstance(conf.get("package"), dict) and "version" in conf["package"]:
            conf["package"]["version"] = version
          elif "version" in conf:
            conf["version"] = version
          else:
            conf["version"] = version

          conf_path.write_text(json.dumps(conf, indent=2) + "\n", encoding='utf-8')

          cargo_path = Path('src-tauri/Cargo.toml')
          cargo_text = cargo_path.read_text(encoding='utf-8')
          cargo_text = re.sub(r'(?m)^version\s*=\s*"[^"]+"\s*$', f'version = "{version}"', cargo_text, count=1)
          cargo_path.write_text(cargo_text, encoding='utf-8')
          PY

      - name: Install Linux dependencies
        if: matrix.os == 'ubuntu-22.04'
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            pkg-config \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            librsvg2-dev \
            libsoup-3.0-dev \
            patchelf

          sudo apt-get install -y libayatana-appindicator3-dev || sudo apt-get install -y libappindicator3-dev

          echo "PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/share/pkgconfig" >> $GITHUB_ENV
          pkg-config --modversion libsoup-3.0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      # Add universal target for macOS (builds for both Intel and Apple Silicon)
      - name: Add macOS universal target
        if: matrix.os == 'macos-latest'
        run: |
          rustup target add x86_64-apple-darwin
          rustup target add aarch64-apple-darwin

      - name: Install frontend deps
        run: npm ci

      # Write the signing key (stored in GitHub Secrets) to a file for the signer step
      - name: Write signing key to file
        shell: bash
        run: |
          mkdir -p ~/.tauri
          printf '%s' "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" > ~/.tauri/production-portal.key
          chmod 600 ~/.tauri/production-portal.key

      ######################################################################
      # macOS SIGNING + NOTARIZATION SETUP
      ######################################################################
      - name: Setup macOS signing keychain (Developer ID)
        if: matrix.os == 'macos-latest'
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          KEYCHAIN_PASSWORD="$(uuidgen)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -d user -s "$KEYCHAIN_PATH"

          CERT_PATH="$RUNNER_TEMP/cert.p12"
          echo "$APPLE_CERTIFICATE" | base64 --decode > "$CERT_PATH"

          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "Developer ID cert imported."

      # Works for both config shapes, and removes invalid top-level `tauri` if present
      - name: Set macOS signing identity in tauri.conf.json
        if: matrix.os == 'macos-latest'
        shell: bash
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, os
          from pathlib import Path

          identity = os.environ.get("APPLE_SIGNING_IDENTITY")
          if not identity:
            raise SystemExit("APPLE_SIGNING_IDENTITY is not set")

          conf_path = Path("src-tauri/tauri.conf.json")
          conf = json.loads(conf_path.read_text(encoding="utf-8"))

          # If the project is on the newer config shape, top-level "tauri" is invalid.
          if "tauri" in conf and ("app" in conf or "plugins" in conf):
            conf.pop("tauri", None)

          # Two supported shapes:
          # - Older: conf["tauri"]["bundle"]["macOS"]["signingIdentity"]
          # - Newer: conf["bundle"]["macOS"]["signingIdentity"]
          if "tauri" in conf:
            conf.setdefault("tauri", {})
            conf["tauri"].setdefault("bundle", {})
            conf["tauri"]["bundle"].setdefault("macOS", {})
            conf["tauri"]["bundle"]["macOS"]["signingIdentity"] = identity
          else:
            conf.setdefault("bundle", {})
            conf["bundle"].setdefault("macOS", {})
            conf["bundle"]["macOS"]["signingIdentity"] = identity

          conf_path.write_text(json.dumps(conf, indent=2) + "\n", encoding="utf-8")
          print("Set macOS signing identity:", identity)
          PY

      ######################################################################
      # BUILDS
      ######################################################################
      - name: Build desktop app (Tauri) - Linux/Windows
        if: matrix.os != 'macos-latest'
        run: npm run tauri:build
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      # Build universal binary for macOS (both Intel and Apple Silicon)
      - name: Build desktop app (Tauri) - macOS Universal
        if: matrix.os == 'macos-latest'
        run: npm run tauri:build -- --target universal-apple-darwin
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      ######################################################################
      # NOTARIZE macOS DMG (ROBUST)
      ######################################################################
      - name: Notarize + staple macOS DMG
        if: matrix.os == 'macos-latest'
        shell: bash
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail

          DMG=$(find src-tauri/target/universal-apple-darwin/release/bundle -name "*.dmg" -type f 2>/dev/null | head -1)
          if [ -z "$DMG" ]; then
            DMG=$(find src-tauri/target/release/bundle -name "*.dmg" -type f 2>/dev/null | head -1)
          fi

          if [ -z "$DMG" ] || [ ! -f "$DMG" ]; then
            echo "Could not find DMG to notarize" >&2
            exit 1
          fi

          echo "Submitting for notarization: $DMG"

          retry() {
            local n=0
            local max=5
            local delay=20
            until "$@"; do
              n=$((n+1))
              if [ "$n" -ge "$max" ]; then
                echo "Command failed after $n attempts: $*" >&2
                return 1
              fi
              echo "Command failed (attempt $n/$max). Retrying in ${delay}s..." >&2
              sleep "$delay"
              delay=$((delay*2))
            done
          }

          SUBMIT_OUT="$RUNNER_TEMP/notary_submit.txt"
          : > "$SUBMIT_OUT"

          # Capture submit output (stdout+stderr) into a file
          retry bash -lc "xcrun notarytool submit \"$DMG\" \
            --apple-id \"$APPLE_ID\" \
            --password \"$APPLE_APP_SPECIFIC_PASSWORD\" \
            --team-id \"$APPLE_TEAM_ID\" \
            --output-format json" > "$SUBMIT_OUT" 2>&1

          echo "Submit output:"
          cat "$SUBMIT_OUT"

          # Parse the UUID from the JSON file (fail hard if missing)
          UUID=$(python3 - "$SUBMIT_OUT" <<'PY'
          import json, re, pathlib, sys

          path = sys.argv[1]
          s = pathlib.Path(path).read_text(encoding="utf-8", errors="replace").strip()

          try:
            data = json.loads(s)
          except Exception:
            m = re.search(r'(\{.*\})', s, flags=re.S)
            if not m:
              raise SystemExit("Could not find JSON in submit output.")
            data = json.loads(m.group(1))

          uid = data.get("id", "")
          if not uid or not re.fullmatch(r"[0-9a-fA-F-]{36}", uid):
            raise SystemExit(f"Invalid or missing UUID in submit output: {uid!r}")

          print(uid)
          PY
          )

          echo "Notary submission id: $UUID"

          retry xcrun notarytool wait "$UUID" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID"

          echo "Stapling notarization ticket..."
          retry xcrun stapler staple "$DMG"

          echo "Gatekeeper verification:"
          spctl -a -vv "$DMG" || true

      ######################################################################
      # COLLECT ARTIFACTS
      ######################################################################
      - name: Collect artifact info (Linux)
        if: matrix.os == 'ubuntu-22.04'
        shell: bash
        run: |
          mkdir -p artifacts
          
          APPIMAGE=$(find src-tauri/target/release/bundle -name "*.AppImage" -type f | head -1)
          if [ -n "$APPIMAGE" ] && [ -f "$APPIMAGE" ]; then
            cp "$APPIMAGE" artifacts/
            if [ -f "$APPIMAGE.sig" ]; then
              SIGNATURE=$(cat "$APPIMAGE.sig")
              echo "$SIGNATURE" > artifacts/linux-x86_64.sig
            fi
            echo "LINUX_ARTIFACT=$(basename $APPIMAGE)" >> $GITHUB_ENV
          fi
          
          find src-tauri/target/release/bundle -name "*.deb" -exec cp {} artifacts/ \;
          find src-tauri/target/release/bundle -name "*.rpm" -exec cp {} artifacts/ \;

      - name: Collect artifact info (Windows)
        if: matrix.os == 'windows-latest'
        shell: bash
        run: |
          mkdir -p artifacts
          
          MSI=$(find src-tauri/target/release/bundle -name "*.msi" -type f | head -1)
          if [ -n "$MSI" ] && [ -f "$MSI" ]; then
            cp "$MSI" artifacts/
            if [ -f "$MSI.sig" ]; then
              SIGNATURE=$(cat "$MSI.sig")
              echo "$SIGNATURE" > artifacts/windows-x86_64.sig
            fi
            echo "WINDOWS_ARTIFACT=$(basename $MSI)" >> $GITHUB_ENV
          fi
          
          find src-tauri/target/release/bundle -name "*.exe" -exec cp {} artifacts/ \;

      - name: Collect artifact info (macOS)
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          mkdir -p artifacts

          MACOS_UPDATE=$(find src-tauri/target/universal-apple-darwin/release/bundle/macos -name "*.app.tar.gz" -type f 2>/dev/null | head -1)
          if [ -z "$MACOS_UPDATE" ]; then
            MACOS_UPDATE=$(find src-tauri/target/release/bundle/macos -name "*.app.tar.gz" -type f 2>/dev/null | head -1)
          fi

          if [ -n "$MACOS_UPDATE" ] && [ -f "$MACOS_UPDATE" ]; then
            cp "$MACOS_UPDATE" artifacts/
            if [ -f "$MACOS_UPDATE.sig" ]; then
              SIGNATURE=$(cat "$MACOS_UPDATE.sig")
              echo "$SIGNATURE" > artifacts/darwin-aarch64.sig
              echo "$SIGNATURE" > artifacts/darwin-x86_64.sig
            fi
            echo "MACOS_ARTIFACT=$(basename "$MACOS_UPDATE")" >> $GITHUB_ENV
          fi

          DMG=$(find src-tauri/target/universal-apple-darwin/release/bundle -name "*.dmg" -type f 2>/dev/null | head -1)
          if [ -z "$DMG" ]; then
            DMG=$(find src-tauri/target/release/bundle -name "*.dmg" -type f 2>/dev/null | head -1)
          fi
          if [ -n "$DMG" ] && [ -f "$DMG" ]; then
            cp "$DMG" artifacts/
          fi

      # Upload installer artifacts
      - name: Upload installers
        uses: actions/upload-artifact@v4
        with:
          name: installers-${{ matrix.platform }}
          if-no-files-found: error
          path: artifacts/

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/desktop-v')

    steps:
      - name: Download all installers
        uses: actions/download-artifact@v4
        with:
          pattern: installers-*
          path: dist
          merge-multiple: true

      - name: List downloaded artifacts
        run: |
          echo "Downloaded artifacts:"
          find dist -type f -ls

      - name: Create Release + Upload Assets
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          name: Production Portal ${{ github.ref_name }}
          body: |
            ## Desktop installers for Production Portal
            
            | Platform | Download |
            |----------|----------|
            | macOS (Universal) | `.dmg` file below |
            | Windows | `.msi` file below |
            | Linux | `.AppImage`, `.deb`, or `.rpm` files below |
            
            The app will automatically check for updates.
          allowUpdates: true
          replacesArtifacts: true
          artifacts: |
            dist/*.AppImage
            dist/*.deb
            dist/*.rpm
            dist/*.dmg
            dist/*.app.tar.gz
            dist/*.msi
            dist/*.exe
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate latest.json (use actual uploaded asset URLs)
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          TAG="${{ github.ref_name }}"
          VERSION="${TAG#desktop-v}"
          REPO="WovenTexLTD/line-lead-hub"
          PUB_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          curl -sSL \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/releases/tags/$TAG" \
            > dist/release.json

          python3 - <<'PY' > dist/asset_urls.env
          import json

          with open('dist/release.json', 'r', encoding='utf-8') as f:
            data = json.load(f)

          assets = data.get('assets', []) or []

          def find_url(endswith: str) -> str:
            for a in assets:
              name = a.get('name', '') or ''
              if name.endswith(endswith):
                return a.get('browser_download_url', '') or ''
            return ''

          linux_url = find_url('.AppImage')
          windows_url = find_url('.msi')
          macos_url = find_url('.app.tar.gz')

          print(f"LINUX_URL={linux_url}")
          print(f"WINDOWS_URL={windows_url}")
          print(f"MACOS_URL={macos_url}")
          PY

          source dist/asset_urls.env

          if [ -z "${LINUX_URL:-}" ]; then
            echo "Could not find Linux .AppImage asset URL in release" >&2
            exit 1
          fi
          if [ -z "${WINDOWS_URL:-}" ]; then
            echo "Could not find Windows .msi asset URL in release" >&2
            exit 1
          fi
          if [ -z "${MACOS_URL:-}" ]; then
            echo "Could not find macOS .app.tar.gz asset URL in release" >&2
            exit 1
          fi

          if [ ! -f "dist/linux-x86_64.sig" ] || [ ! -f "dist/windows-x86_64.sig" ]; then
            echo "Missing linux-x86_64.sig or windows-x86_64.sig in dist" >&2
            exit 1
          fi

          LINUX_SIG=$(tr -d '\n' < dist/linux-x86_64.sig)
          WINDOWS_SIG=$(tr -d '\n' < dist/windows-x86_64.sig)

          DARWIN_SIG=""
          if [ -f "dist/darwin-aarch64.sig" ]; then
            DARWIN_SIG=$(tr -d '\n' < dist/darwin-aarch64.sig)
          elif [ -f "dist/darwin-x86_64.sig" ]; then
            DARWIN_SIG=$(tr -d '\n' < dist/darwin-x86_64.sig)
          fi

          if [ -z "$DARWIN_SIG" ]; then
            echo "Missing macOS signature (darwin-aarch64.sig or darwin-x86_64.sig) in dist" >&2
            exit 1
          fi

          cat > dist/latest.json << EOF
          {
            "version": "$VERSION",
            "notes": "Production Portal update",
            "pub_date": "$PUB_DATE",
            "platforms": {
              "linux-x86_64": { "url": "$LINUX_URL", "signature": "$LINUX_SIG" },
              "windows-x86_64": { "url": "$WINDOWS_URL", "signature": "$WINDOWS_SIG" },
              "darwin-aarch64": { "url": "$MACOS_URL", "signature": "$DARWIN_SIG" },
              "darwin-x86_64": { "url": "$MACOS_URL", "signature": "$DARWIN_SIG" }
            }
          }
          EOF

          echo "Generated latest.json:"
          cat dist/latest.json

      - name: Upload latest.json
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          allowUpdates: true
          replacesArtifacts: true
          artifacts: dist/latest.json
          token: ${{ secrets.GITHUB_TOKEN }}
